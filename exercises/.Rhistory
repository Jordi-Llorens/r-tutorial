source('~/Desktop/PhD/TA/R_Brushup/exercises/Untitled.R')
capital <- 18000  # if you invested your tuition fee in an index fund instead
t <- 35  # ~retirement age
r <- 8  # average return of an index fund, e.g. Vanguard S&P500
i <- 1
while ( i <= t ){
print(i)
capital <- capital * (1 + r/100)
i <- i + 1
}
# check the result
capital
ex <- "Introduction to Computing."  # some text example
n <- 2  # bigrams
# first, remove spaces and dot character by using "gsub" function
ex <- gsub(x = ex, pattern ="[ \\.]", replacement = "")
# next, transform all the text to lower case by using "tolower" function
ex <- tolower(ex)
result <- NULL
repeat {
# use "substr" function to subset the string according the position
# make it a function of length of result vector
result <- c(result, substr(ex,length(result) + 1, length(result) + n))
# use the "break" keyword in combination with an if condition
# you will need the number of characters in the string vector in the
# condition
if (length(result) + n > nchar(ex)) {
break
}
}
ex <- "Introduction to Computing."  # some text example
n <- 2  # bigrams
?gsub
gsub(' ', '', ex)
ex <- "Introduction to Computing."  # some text example
n <- 2  # bigrams
# first, remove spaces and dot character by using "gsub" function
gsub(' ', '', ex)
# first, remove spaces and dot character by using "gsub" function
ex <- gsub(' ', '', ex)
help(tolower)
tolower(ex)
# next, transform all the text to lower case by using "tolower" function
ex <- tolower(ex)
substr(ex, 1,2)
substr(ex, 3,4)
substr(ex,1,n)
substr(ex,2,2*n)
substr(ex,3,2*n)
result <- NULL
length(result)
result <- substr(ex, length(result) + 1, length(result) + n)
result <- substr(ex, length(result) + 1, length(result) + n)
result <- substr(ex, length(result) + 1, length(result) + n)
result <- substr(ex, length(result) + 1, length(result) + n)
result <- substr(ex, length(result) + 1, length(result) + n)
# use "substr" function to subset the string according the position
result <- substr(ex, length(result) + 1, length(result) + n)
result <- NULL
# use "substr" function to subset the string according the position
result <- substr(ex, length(result) + 1, length(result) + n)
# use "substr" function to subset the string according the position
result <- substr(ex, length(result) + 1, length(result) + n)
result <- NULL
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
length(result)
nchar(ex)
nchar(ex)/n
floor(nchar(ex)/n)
ex <- "Introduction to Computing."  # some text example
n <- 2  # bigrams
# first, remove spaces and dot character by using "gsub" function
ex <- gsub(' ', '', ex)
# next, transform all the text to lower case by using "tolower" function
ex <- tolower(ex)
result <- NULL
repeat {
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
# use the "break" keyword in combination with an if condition
# you will need the number of characters in the string vector in the
# condition
if ( length(result) == floor(nchar(ex)/n) ) break
}
# check the result
result
source('~/Desktop/PhD/TA/R_Brushup/exercises/1.loops_inclass.R', echo=TRUE)
result <- NULL
repeat {
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
# use the "break" keyword in combination with an if condition
# you will need the number of characters in the string vector in the
# condition
}
result <- NULL
repeat {
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
browser()
# use the "break" keyword in combination with an if condition
# you will need the number of characters in the string vector in the
# condition
}
nchar(ex)
result <- NULL
repeat {
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
# use the "break" keyword in combination with an if condition
# you will need the number of characters in the string vector in the
# condition
if ( length(result) == 24 ){
browser()
break
}
}
result <- NULL
repeat {
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
# use the "break" keyword in combination with an if condition
# you will need the number of characters in the string vector in the
# condition
if ( length(result) == 24 ){
browser()
break
}
}
result <- NULL
repeat {
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
# use the "break" keyword in combination with an if condition
# you will need the number of characters in the string vector in the
# condition
browser()
if ( length(result) == 24 ){
break
}
}
ex <- "Introduction to Computing."  # some text example
n <- 2  # bigrams
# first, remove spaces and dot character by using "gsub" function
ex <- gsub(' ', '', ex)
# next, transform all the text to lower case by using "tolower" function
ex <- tolower(ex)
result <- NULL
repeat {
# use "substr" function to subset the string according the position
result <- c(result, substr(ex, length(result) + 1, length(result) + n))
# use the "break" keyword in combination with an if condition
# you will need the number of characters in the string vector in the
# condition
# browser()
if ( length(result) == 24 ){
browser()
break
}
}
assertthat::is.number(c(1,2))
assertthat::is.number(1
)
assertthat::is.number('1')
assertthat::is.scalar('1')
?stopifnot
?is.atomic
is.atomic(NULL)
is.numeric(NULL)
is.numeric(numeric(0))
meanme <- function(x, loop = FALSE, na.rm = FALSE) {
# first verify that input, x, has the expected form, using "stopifnot" fnc
# e.g. it should be an atomic vector
stopifnot(is.atomic(x))
# it should also be a numeric vector
stopifnot(is.numeric(x))
# this is called defensive programming, preventing unexpected inputs
# and warning user about it, check "assertthat" package
# always take into account exceptions, e.g. numeric vectors often
# have missing values. If "na.rm" is set to TRUE remove them from x
# we will have two ways of computing the mean, one will be with a loop
# if "loop" argument is set to TRUE
if (loop) {
x <- 0
for (i in 1:length(x)){
S <- S + x[i]
}
result <- S / length(x)
# in the second way will be by using matrix operations
# to compute the sum (%*% or crossprod fnc)
} else {
result <- x %*% rep(1,length(x)) / length(x)
}
return(c(result))
}
debug(meanme)
meanme(x, loop = F)
set.seed(1234)
x <- rnorm(100, 5, 10)
debug(meanme)
meanme <- function(x, loop = FALSE, na.rm = FALSE) {
# first verify that input, x, has the expected form, using "stopifnot" fnc
# e.g. it should be an atomic vector
stopifnot(is.atomic(x))
# it should also be a numeric vector
stopifnot(is.numeric(x))
# this is called defensive programming, preventing unexpected inputs
# and warning user about it, check "assertthat" package
# always take into account exceptions, e.g. numeric vectors often
# have missing values. If "na.rm" is set to TRUE remove them from x
# we will have two ways of computing the mean, one will be with a loop
# if "loop" argument is set to TRUE
if (loop) {
x <- 0
for (i in 1:length(x)){
S <- S + x[i]
}
result <- S / length(x)
# in the second way will be by using matrix operations
# to compute the sum (%*% or crossprod fnc)
} else {
result <- x %*% rep(1,length(x)) / length(x)
}
return(c(result))
}
meanme(x, loop = F)
debug(meanme)
meanme(x, loop = F)
debugSource('~/Desktop/PhD/TA/R_Brushup/exercises/functions_inclass.R', echo=TRUE)
debugSource('~/Desktop/PhD/TA/R_Brushup/exercises/functions_inclass.R', echo=TRUE)
x
debug(meanme)
debugSource('~/Desktop/PhD/TA/R_Brushup/exercises/functions_inclass.R', echo=TRUE)
debugSource('~/Desktop/PhD/TA/R_Brushup/exercises/functions_inclass.R')
x %*% rep(1,length(x)) / length(x)
x %*% rep(1,length(x)) / length(x)
meanme(1:3) == 2
undebug(meanme)
meanme(1:3) == 2
meanme <- function(x, loop = FALSE, na.rm = FALSE) {
# first verify that input, x, has the expected form, using "stopifnot" fnc
# e.g. it should be an atomic vector
stopifnot(is.atomic(x))
# it should also be a numeric vector
stopifnot(is.numeric(x))
# this is called defensive programming, preventing unexpected inputs
# and warning user about it, check "assertthat" package
# always take into account exceptions, e.g. numeric vectors often
# have missing values. If "na.rm" is set to TRUE remove them from x
# we will have two ways of computing the mean, one will be with a loop
# if "loop" argument is set to TRUE
if (loop) {
S <- 0
for (i in 1:length(x)){
S <- S + x[i]
}
result <- S / length(x)
# in the second way will be by using matrix operations
# to compute the sum (%*% or crossprod fnc)
} else {
result <- x %*% rep(1,length(x)) / length(x)
}
return(c(result))
}
meanme(x, loop = F)
meanme(1:3) == 2
is.na(meanme(c(1:3, NA)))
meanme(c(1:3, NA), na.rm = TRUE) == 2
set.seed(1234)
x <- rnorm(100, 5, 10)
meanme <- function(x, loop = FALSE, na.rm = FALSE) {
# first verify that input, x, has the expected form, using "stopifnot" fnc
# e.g. it should be an atomic vector
stopifnot(is.atomic(x))
# it should also be a numeric vector
stopifnot(is.numeric(x))
# this is called defensive programming, preventing unexpected inputs
# and warning user about it, check "assertthat" package
# always take into account exceptions, e.g. numeric vectors often
# have missing values. If "na.rm" is set to TRUE remove them from x
if (na.rm) {
x <- x[ !is.na(x) ]
}
# we will have two ways of computing the mean, one will be with a loop
# if "loop" argument is set to TRUE
if (loop) {
S <- 0
for (i in 1:length(x)){
S <- S + x[i]
}
result <- S / length(x)
# in the second way will be by using matrix operations
# to compute the sum (%*% or crossprod fnc)
} else {
result <- x %*% rep(1,length(x)) / length(x)
}
return(c(result))
}
# NOTE: When you execute a function R creates a special environment for that
# function call and everything that gets created within the function will not
# be available outside of the function call. For example, in the function
# above object "result" will not be available outside of it.
# lets check out the function
meanme(x, loop = F)
# you should get: 3.432383
profvis::profvis({set.seed(1234)
x <- rnorm(100, 5, 10)
meanme <- function(x, loop = FALSE, na.rm = FALSE) {
# first verify that input, x, has the expected form, using "stopifnot" fnc
# e.g. it should be an atomic vector
stopifnot(is.atomic(x))
# it should also be a numeric vector
stopifnot(is.numeric(x))
# this is called defensive programming, preventing unexpected inputs
# and warning user about it, check "assertthat" package
# always take into account exceptions, e.g. numeric vectors often
# have missing values. If "na.rm" is set to TRUE remove them from x
if (na.rm) {
x <- x[ !is.na(x) ]
}
# we will have two ways of computing the mean, one will be with a loop
# if "loop" argument is set to TRUE
if (loop) {
S <- 0
for (i in 1:length(x)){
S <- S + x[i]
}
result <- S / length(x)
# in the second way will be by using matrix operations
# to compute the sum (%*% or crossprod fnc)
} else {
result <- x %*% rep(1,length(x)) / length(x)
}
return(c(result))
}
# NOTE: When you execute a function R creates a special environment for that
# function call and everything that gets created within the function will not
# be available outside of the function call. For example, in the function
# above object "result" will not be available outside of it.
# lets check out the function
meanme(x, loop = F)
# you should get: 3.432383})
profvis::profvis({set.seed(1234)
x <- rnorm(100, 5, 10)
meanme <- function(x, loop = FALSE, na.rm = FALSE) {
# first verify that input, x, has the expected form, using "stopifnot" fnc
# e.g. it should be an atomic vector
stopifnot(is.atomic(x))
# it should also be a numeric vector
stopifnot(is.numeric(x))
# this is called defensive programming, preventing unexpected inputs
# and warning user about it, check "assertthat" package
# always take into account exceptions, e.g. numeric vectors often
# have missing values. If "na.rm" is set to TRUE remove them from x
if (na.rm) {
x <- x[ !is.na(x) ]
}
# we will have two ways of computing the mean, one will be with a loop
# if "loop" argument is set to TRUE
if (loop) {
S <- 0
for (i in 1:length(x)){
S <- S + x[i]
}
result <- S / length(x)
# in the second way will be by using matrix operations
# to compute the sum (%*% or crossprod fnc)
} else {
result <- x %*% rep(1,length(x)) / length(x)
}
return(c(result))
}
# NOTE: When you execute a function R creates a special environment for that
# function call and everything that gets created within the function will not
# be available outside of the function call. For example, in the function
# above object "result" will not be available outside of it.
# lets check out the function
meanme(x, loop = F)
# you should get: 3.432383})
profvis::profvis({set.seed(1234)
x <- rnorm(100, 5, 10) })
meanme(1:3) == 2
is.na(meanme(c(1:3, NA)))
meanme(c(1:3, NA), na.rm = TRUE) == 2
# Let's compare how efficient is your function for mean in comparison
# to built in R function
y <- rnorm(1000000)
system.time({
meanme(y)
})
system.time({
mean(y)
})
system.time({
meanme(y, TRUE)
})
n <- '1'
stopifnot(is.numeric(n) & length(n) == 1)
fibonnacci <- function(n) {
# first verify that input, n, has the expected form, using "stopifnot" fnc
# e.g. it should be a scalar
stopifnot(is.numeric(n) & length(n) == 1)
# it should also be a positive number
stopifnot(n >= 0)
# initial conditions F(0)=0, F(1)=1.
switch(n, 0=return(0), 1=return(1))
# in the sequence each element is a sum of previous two numbers
# here you will call the function itself!
# YOU CODE
}
fibonnacci <- function(n) {
# first verify that input, n, has the expected form, using "stopifnot" fnc
# e.g. it should be a scalar
stopifnot(is.numeric(n) & length(n) == 1)
# it should also be a positive number
stopifnot(n >= 0)
# initial conditions F(0)=0, F(1)=1.
if (n == 0) return(0)
if (n == 1) return(1)
# in the sequence each element is a sum of previous two numbers
# here you will call the function itself!
return( fibonacci(n-1) + fibonacci(n-2))
}
# apply the function
fibonnacci(0)   # 0
fibonnacci(1)   # 1
fibonnacci(10)  # 55
fibonnacci <- function(n) {
# first verify that input, n, has the expected form, using "stopifnot" fnc
# e.g. it should be a scalar
stopifnot(is.numeric(n) & length(n) == 1)
# it should also be a positive number
stopifnot(n >= 0)
# initial conditions F(0)=0, F(1)=1.
if (n == 0) return(0)
if (n == 1) return(1)
# in the sequence each element is a sum of previous two numbers
# here you will call the function itself!
return( fibonnacci(n-1) + fibonnacci(n-2))
}
# apply the function
fibonnacci(0)   # 0
fibonnacci(1)   # 1
fibonnacci(10)  # 55
# to get a whole sequence
sapply(1:10, fibonnacci)
fibonnacci(pi)
bernoulli <- function(n, p) {
# implement some checks of function arguments
# n positive scalar
stopifnot( is.numeric(n) & n > 0)
# 0 < p < 1 (numeric scalar)
stopifnot( is.numeric(p) & p >= 0 & p <= 1 )
# generate a sequence of 0 and 1, using an "ifelse" function where
# a condition is a function of runif draw and probability p
u <- runif(n)
draws <- ifelse(u < p, 1, 0)
return(draws)
}
# check it out
bernoulli(10, 0.2)
debug(bernoulli)
# check it out
bernoulli(10, 0.2)
u
set.seed(1234)
bernoulli(10, 0.2)
all.equal(
mean(bernoulli(100000, 0.2)),
0.2,
tolerance = 0.01
)
# define a dice of 12 faces and use "sample" function to draw 4 dice throws
dice <- 1:12
sample(dice, 4, replace = TRUE)
sum(range(dice))/2
(max(dice) - 1)*(max(dice) + 1)/max(dice)
range(dice)
# define a dice of 12 faces and use "sample" function to draw 4 dice throws
dice <- 1:12
sample(dice, 4, replace = TRUE)
set.seed(1234)
MC <- c()
n <- 200
for (i in 1:n) {
sm <- mean(sample(dice, 3, replace = TRUE))
MC <- c(MC, sm)
}
head(MC)
set.seed(1234)
MC <- c()
n <- 200
for (i in 1:n) {
sm <- mean(sample(dice, 3, replace = TRUE))
MC <- c(MC, sm)
}
head(MC)
hist(MC, breaks = 16, xlim = c(1,12), probability = TRUE)
xfit <- seq(min(MC),max(MC),length=40)
yfit <- dnorm(xfit, mean = mean(MC), sd = sd(MC))
lines(xfit, yfit, col="blue", lwd=2)
mean(MC)
sd(MC)
